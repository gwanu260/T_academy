/**
 * 객체
 *  - 데이터 관점에서 체크 => 키:값을 가진 컬렉션 타입 => 파이썬의 dict 와 동일함
 *  - 클래스, 객체라는 관점이 적용 -> 객체지향 프로그램이 반영되는 형태
 *  - {}
 *  - 용어정리
 *      - 엔티티 : 이세상에 존재하는 모든 유형(사람, 차,..)/무형(민주주의, 사랑,..)의 존재를 의미
 *      - 엔티티를 프로그램 세상에 구현(표현)하고 싶다면 -> 문법체계가 필요 -> 클래스
 *      - 클래스 문법으로 엔티티를 묘사 -> 클래스를 구현 (차 클래스 구현)
 *      - 클래스로 작성한 코드가 실제 구동될려면 => 메모리상에 존재해야함 => 메모리상에 생성
 *          => 메모리 상에 생성(클래스의 모습과 거의 동일해야함) => 이것을 객체라고 부름
 *          => 메모리 상에 존재하는 객체는 반드시 주소를 가진다. 
 *          => 이 주소를 가진 변수를 참조형(reference) 변수라고 부름(파이썬, JS의 변수)
 *          => 객체는 클래스와 아주 유사한 형태를 가지고, 객체를 여러개 만들면 같은 형태임
 *      - 클래스의 인스턴스(생성)를 객체라고 부른다
 *      - 이를 기반으로 프로그램을 설계, 개발, 구동 => 객체 지향 프로그래밍(OOP)
 *          - 특징 : 상속성, 다형성, 보안성(데이터는 내부에 숨긴다)
 */


// 객체 생성법 (클래스 정의  -> 생성) , js는 5가지 방법 존재
// (*)1. 객체 리터럴
// 2. object 객체를 확장
// 3. 생성자 함수를 이용 -> 객체에 이름이 생김
// (*)4. 3번 방식 + prototype으로 확장
// 5. class 키워드 이용(전통적 클래스 설계법 도입) -> 리액트등 SPA등에서 주로 보임 , 4번과 동일

// 1. 객체 리터럴 => {}
const object = {};
console.log( object );
// - 1회성 객체 -> 함수|클래스 생성시의 인자로 여럿을 묶어서 전달시 주로 사용
// - 객체를 여러번 생성한다면 적절하지 않음
// 데이터 구성
let height = 180; // 키, 전역변수
let weight = "80"; // 몸무게, 전역변수
// 데이터 여러개 전달을 위해 객체 구성
const obj1 = {
    name:'ABC',
    age:'35',
    height,
    weight,
    arr:[1,2,3,4],
    spec:{},
    // 함수
    getAge:function () {
        // 객체의 멤버를 접근 => 객체명.멤버명
        // 클래스 내부에서는 어떻게 접근? => 자기자신지칭하는객체(this or self).멤버명
        return `${ this.name }의 나이는 ${ this.age} 입니다.`;
    }
};
// 객체 접근하여 데이터 사용
console.log( obj1 );
// 객체명.멤버 변수|함수
console.log( obj1.getAge() );
// 객체명.멤버 변수
console.log( obj1.arr );

// 함수의 인자도 전달 예시
// x:수치값, cb:콜백함수 -> 함수 내 연산 결과를 가져가는 역할
function test( x, cb ) {
    console.log( 1 );
    cb( x+1 ); // 인자로 전달된 함수 호출
    console.log( 2 );
}
// test() 함수 호출
test( 10, function ( y ) {
    console.log( '연산결과값 => ', y);
} );

// 대량 데이터 전달
// type : 데이터 1개
// params : {} 형채로 n개의 데이터 가진 형태
function test2( type, params ) {
    console.log( type, params.name, params.age, params.height);    
}
test2( "check", obj1 );
test2( "check", { 
    name:"hi",
    age:10,
    height:190
} );

// 4. 번 스타일 생성자 함수 -> 클래스 구성, prototype으로 멤버 확장
function Memo( nm ) {
    // 멤버 지정
    this.nm = nm // 멤버 변수 선언 및 초기화
}
// 객체 생성 -> 대부분 언어 동일함 => new 키워드 사용
const memo = new Memo( 'JS' );
console.log( memo ); // Memo { nm: 'JS' }
// 별칭 데이터를 확장 -> 멤버 추가
Memo.prototype.nickname = '별칭'; // 공용 메모리 관리 -> 메모리 효율적이게 됨
console.log( memo.nickname );
console.log( memo );


// 결론
// 1번 유형을 가장 많이 사용
// 설계 등 필요하면 4(라이브러리 설계시), 5번(리액트 등) 사용

